# 数据结构与算法(七)：外部查找与不相交集(Re:算法导论 & 数据结构：思想与实现)

## 外存储器
相比于内存，外存储器有价格低廉、存储量大和永久保存等优点，但也有**访问速度慢**的缺点。在考虑处理外存储器上数据的算法时应该重点考虑如何减少访问次数。在设计基于外存的算法时，宁愿做很多的计算来避免一次外存访问。在包含外存操作的情况下，**外存访问的次数决定了操作的运行时间**。

## B树

B树是一种存储在外存储器的**动态查找表**。内存中的查找表通常被组织成为一棵二叉查找树或平衡二叉树。但如果存储在磁盘上的信息也被组织成为一棵查找树，那么它的访问时间是灾难性的，因为一般访问一个元素需要其深度那么多次的磁盘访问。要减少磁盘的访问次数，就必须降低查找树的高度。解决方法非常简单，**只需要树的分支多一些**，高度就能降下来。

构造M叉查找树的方法和二叉查找树很类似，只不过在M叉查找树中每个节点需要**保存M-1个键**来判断到哪个分支中继续操作。同二叉树一样，M叉树也需要一定的方法来使其维持平衡。B树就是一棵平衡的m叉查找树，主要用于大型文件的索引，其定义如下：
一棵m阶B树或者为空，或者满足以下条件：
- 根节点要么是叶子，要么至少有两个儿子，至多有m个儿子
- 除根节点和叶子节点以外，每个节点的儿子数s满足 $m/2 \leq s \leq m$
- 有s个儿子的非叶节点具有$n=s-1$个关键字，故$s=n+1$
- 所有叶子节点都出现在同一层上，即它们的深度相同，并且不带信息

一次磁盘读写可以读入磁盘上的一个块。因此，在B数的设计中可以**将一个磁盘块作为一个B树的节点**，根据磁盘块的大小、关键字的长度以及磁盘地址的长度来决定B树的阶数。

**B树的操作：**

查找时和二叉树一样，与各关键字比较后选择下一层的儿子节点。插入时，若原有节点的关键字个数已经等于m-1,则该节点必须分裂成两个节点。分裂节点的过程是将原节点的中间值提到父节点，然后再将左右两边的值分裂成为两个节点。若父节点的关键字个数也达到了n-1，则进行新一轮的分裂。在根节点上，可能会创建一个新的节点，导致B树长高一层。

B树的删除更为复杂些。若删除的是底部节点的关键字，则可直接删除。否则删除后，需要寻找其代替关键字：用其最左面的节点的关键字值，即处于最底层的最小关键字值取代。然后，删除最底层的该关键字。若此时该节点的关键字个数小于$m/2 - 1$，则可从其左右兄弟节点中借一个关键字。若无关键字可借，则必须合并两个节点，此时父节点相应的关键字也要并入该合并节点。若父节点的关键字也不满足定义，则继续调整至满足定义为止。最坏情况下，可能会导致根节点的删除。

## B+树

既能支持每个记录的随机访问也能支持对整个文件按关键字次序访问的文件称为**索引顺序文件**。B+树是用于索引顺序文件的数据结构。它既要考虑**索引是有序**的，也要考虑保证**文件记录的有序性**。

鉴于B+树既要考虑到索引的组织，又要考虑到记录本身的存放，M阶的B+树被定义为具有以下性质的M叉树：
- 根或者为叶子，或者有2到M个孩子
- 除根之外所有节点都有不少于M\2且不多于M个孩子
- 有k个孩子的节点保存了k-1个键来索引查找，建i代表了子树i+1中键的最小值
- 叶节点中的孩子指针指向存储记录的数据块的地址。
- 每个数据块至少有L\2个记录，最多有L个记录
- 所有的叶节点按序连成一个单链表

## 外排序

在外存上进行排序的最常用的方法就是利用**归并排序**。这种方法由两个阶段组成：预处理阶段和归并阶段。预处理阶段根据内存大小将一个有n个记录的文件分批读入内存，用各种内排序算法排序，形成一个个有序的小文件。如果内存能够读入p个记录，那么每个初始的已排序片段都包含p个或小于p个的记录。归并阶段将小文件逐步归并成为一个有序文件。归并可以由二路归并或者k路归并来完成。

**置换选择：** 置换选择可以在只能容纳p个记录的内存中生成平均长度为2p的初始的已排序片段。置换选择法是基于每个小片段采用选择排序。每次选出的最小记录直接被写到输出文件上，它所用的内存空间就可以给别的元素使用，此时可以从输入文件读入一个新记录。如果读入的记录比刚刚输出的记录大，它能被放入这个已排序片段，则让它参加这次排序。

## 不相交集

等价类形成了对集合S的一种分割。对于任意两个等价类$S_i$和$S_j$,$S_i \cap S_j = \Phi$，将所有的等价类并起来就是集合S。这样额集合称为不相交集合。不相交集的两个基本操作是find和union，因此不相交集也被称为**并查集**。

### 2.1 不相交集的存储实现

集合可以用**顺序表**存储，也可以用**树**来存储。用顺序表实现存储结构时，其查找时间复杂度为$O(1)$，但归并时时间复杂度为$O(N)$。若采用树存储，则整个集合就是一个森林结构，树的根节点就是每个子集的标识。并操作只需要将一棵树作为另一棵树的子树就可以了，时间复杂度为$O(1)$。由于每个节点只需要知道其父节点，故可以采用采用**双亲表示法**存储。在双亲表示法中，集合中的所有元素都储存在一个整型数组中：数组的每个元素parent[i]表示元素i的父节点的下标值，如果该元素为根节点，则用一个特殊的值表示，如-1。根节点的下标值就是该子集的标识。

**不相交集的定义：**
```cpp
class DisjointSet{
    private:
        int size;
        int *parent;

    public:
        DisjointSet(int n);
        ~DisjointSet(){
            delete[] parent;
        }
        void Union(int root1, int root2);
        int Find(int x);
};
```

### 2.2 不相交集的运算实现

#### 2.2.1 Union
为了避免union操作造成树的退化，可以采用以下策略：
- 按规模并：将规模小的树作为规模大的树的子树
- 按高度并：将较矮的树作为较高的树的子树

这样进行归并的话必须知道每个子集的规模或者高度，但其实只需要一个小小的改进就可以保存这些信息：**将根节点所保存的值设为负数，其绝对值作为树的规模或者高度**。这样按规模并和按高度并就很容易实现了。

#### 2.2.2 Find
**路径压缩：**从x到根节点的**路径上的每一个节点都将自己的父节点改为根节点**。如果x是一个很深的节点，那么这一操作将会大大降低树的高度。路径压缩能完美地与按规模并兼容，但和按高度并却并不完全兼容，因为路径压缩会改变树地高度。

**不相交集类成员函数的实现：**
```cpp
DisjointSet::DisjointSet(int n){
    parent = new int[n];
    size = n;
    for(int i = 0; i < size; i++){
        parent[i] = -1
    }
}

DisjointSet::~DisjointSet(){
    delete[] parent;
}

void DisjointSet::Union(int root1, int root2){
    if(parent[root1] < parent[root2]){
        parent[root1] += parent[root2];
        parent[root2] = root1;
    }else{
        parent[root2] += parent[root1];
        parent[root1] = root2;
    }
}

int DisjointSet::Find(int x){
    if(parent[x] < 0){
        return x; 
    }else{
        int result = Find(parent[x]);
        parent[x] = result;
        return result;
    }
}
```

**Remark:**
- 注意按规模并和路径压缩的实现

**性能分析：**
- Find的时间复杂度为$O(logN)$
- Union的时间复杂度为$O(1)$


